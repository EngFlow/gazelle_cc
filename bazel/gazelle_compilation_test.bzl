"""
Checks that test data for gazelle_generation_test() makes sense, i.e., that the BUILD files generated by Gazelle allow
the workspace to be built successfully by Bazel.
"""

load("@bazel_binaries//:defs.bzl", "bazel_binaries")
load("@bazel_skylib//lib:paths.bzl", "paths")
load("@rules_bazel_integration_test//bazel_integration_test:defs.bzl", "bazel_integration_test")

def _rename_input_file(ctx, root_dir, input_file):
    output_relative_path = paths.relativize(input_file.path, ctx.label.package).removesuffix(ctx.attr.trimmed_suffix)
    output_path = paths.join(root_dir, output_relative_path)
    return ctx.actions.declare_file(output_path)

def _convert_directory_structure_impl(ctx):
    # Ignore BUILD.in files
    input_files = [
        file
        for file in ctx.files.workspace_files
        if not file.basename.endswith(ctx.attr.ignored_files_suffix)
    ]

    # Rename BUILD.out to BUILD.bazel
    root_dir = ctx.attr.name + "_"
    output_files = [_rename_input_file(ctx, root_dir, input_file) for input_file in input_files]

    # Copy file contents
    for input_file, output_file in zip(input_files, output_files):
        ctx.actions.run_shell(
            mnemonic = "GazelleTestDataConversion",
            inputs = [input_file],
            outputs = [output_file],
            arguments = [input_file.path, output_file.path],
            command = 'cp "$1" "$2"',
        )

    return DefaultInfo(files = depset(output_files))

_convert_directory_structure = rule(
    doc = """
    Prepares a test workspace intended for gazelle_generation_test() to make it buildable by Bazel. To achieve this, all
    BUILD.out files are renamed to BUILD.bazel files.
    """,
    implementation = _convert_directory_structure_impl,
    attrs = {
        "workspace_files": attr.label_list(
            allow_files = True,
            mandatory = True,
            doc = "Workspace contents intended for gazelle_generation_test()",
        ),
        "ignored_files_suffix": attr.string(
            default = ".in",
            doc = "Suffix of workspace files to be ignored",
        ),
        "trimmed_suffix": attr.string(
            default = ".out",
            doc = "Suffix of workspace files to be trimmed",
        ),
    },
)

def _resolve_workspace_path(test_data):
    for path in test_data:
        if paths.basename(path) in ["WORKSPACE", "MODULE.bazel"]:
            return paths.dirname(path)
    fail("test data must contain either a WORKSPACE or MODULE.bazel file")

def gazelle_compilation_test(*, name, test_data, **kwargs):
    """
    gazelle_compilation_test is a macro complementary to gazelle_generation_test.

    It accepts the same input file structure as gazelle_generation_test, but instead of generating BUILD files from
    scratch, it assumes that BUILD files are already present (i.e., gazelle has already been run) and simply verifies
    that the existing BUILD files allow the workspace to be built successfully by Bazel.

    Args:
        name: The name of the test.
        test_data: Test data files you will pass to the test. Same as for gazelle_generation_test.
        **kwargs: Attributes that are passed directly to the bazel_integration_test macro.
    """
    _convert_directory_structure(
        name = "{}_workspace".format(name),
        workspace_files = test_data,
        testonly = True,
    )

    bazel_integration_test(
        name = name,
        bazel_binaries = bazel_binaries,
        bazel_version = bazel_binaries.versions.current,
        workspace_files = [":{}_workspace".format(name)],
        workspace_path = _resolve_workspace_path(test_data),
        **kwargs
    )
