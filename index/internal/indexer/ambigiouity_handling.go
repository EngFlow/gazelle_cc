// Copyright 2025 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package indexer

import (
	"fmt"
	"log"
	"maps"
	"slices"

	"github.com/EngFlow/gazelle_cc/internal/collections"
	"github.com/bazelbuild/bazel-gazelle/label"
)

func (m Module) WithAmbigiousTargetsResolved() Module {
	selectedTargets := map[label.Label]Target{}
	// We need to index only top-level target that depend on all other remaining targets
	for _, intersectingTargets := range GroupTargetsByHeaders(m.Targets) {
		roots := SelectRootTargets(intersectingTargets)
		if len(roots) == 1 { // happy-path, no ambigious headers in targets
			target := roots[0]
			if _, exists := selectedTargets[target.Name]; !exists {
				log.Printf("%v target: %v, hdrs: %v", m.Repository, target.Name, len(target.Hdrs))
				selectedTargets[target.Name] = target
			}
			continue
		}

		// Exclude header-only targets
		if len(roots) != 1 {
			filteredRoots := collections.Filter(roots, func(target Target) bool {
				return len(target.Sources) > 0
			})
			if len(filteredRoots) != 0 {
				roots = filteredRoots
			}
		}

		// Try search for common dependant project and merge with it
		if len(roots) != 1 {
			rootNames := collections.Map(roots, func(target Target) label.Label { return target.Name })
			dependantTargets := collections.Filter(m.Targets, func(target Target) bool {
				return slices.ContainsFunc(rootNames, func(dep label.Label) bool {
					dep = dep.Rel(target.Name.Repo, target.Name.Pkg)
					return target.Deps.Contains(dep)
				})
			})
			selected := SelectRootTargets(dependantTargets)
			if len(selected) == 1 {
				selected := selected[0]
				if target, exists := selectedTargets[selected.Name]; exists {
					selected = target
				}
				for _, target := range intersectingTargets {
					if target.Name != selected.Name {
						selected.Hdrs.Join(target.Hdrs)
						selected.Includes.Join(target.Includes)
					}
				}
				selectedTargets[selected.Name] = selected
				continue
			}
		}

		// Resolve be excluding ambigious headers
		if len(roots) != 1 {
			// The hdrs sets might be partially disjoint
			counts := map[label.Label]int{}
			for _, root := range roots {
				for _, header := range root.Hdrs.Values() {
					counts[header]++
				}
			}
			ambigiousHdrs := collections.SetOf[label.Label]()
			for header, count := range counts {
				if count >= 2 {
					ambigiousHdrs.Add(header)
				}
			}

			for _, root := range roots {
				root.Hdrs = root.Hdrs.Diff(ambigiousHdrs)
				if len(root.Hdrs) > 0 {
					selectedTargets[root.Name] = root
				}
			}
			continue
		}

		if len(roots) != 1 {
			log.Fatalf("Incosistient state, should be only 1 root target, got %d in %v: %+v", len(roots),
				m.Repository,
				collections.Map(roots, func(r Target) string { return fmt.Sprintf("{Name: %q, deps: %v}", r.Name, r.Deps.Values()) }),
			)
		}
	}

	cpy := *(&m)
	cpy.Targets = slices.Collect(maps.Values(selectedTargets))
	return cpy
}

// Groups targets into disjoint groups based on the their defined headers.
// Allows to find targets that contain at least 1 common header defined in their definition.
// Used to indentify potentially ambigious headers for external dependency providers that don't
// have well defined control over sources, e.g. auto-generated rules generated by conan integraiton.
// Groups that contain multiple entries can be applied to `SelectRootTargets` helper method to find a target behaving as clousere over overlapping headers.
func GroupTargetsByHeaders(targets []Target) [][]Target {
	var groups [][]Target

	// Build adjacency list: map each target index to its neighbors
	adj := make(map[int][]int)
	n := len(targets)
	for i := range n {
		for j := i + 1; j < n; j++ {
			if (targets[i]).Hdrs.Intersects(targets[j].Hdrs) {
				adj[i] = append(adj[i], j)
				adj[j] = append(adj[j], i)
			}
		}
	}

	// DFS to find connected components
	visited := make([]bool, n)
	for i := range n {
		if visited[i] {
			continue
		}
		stack := []int{i}
		component := collections.SetOf(&targets[i])
		visited[i] = true

		for len(stack) > 0 {
			curr := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			for _, neighbor := range adj[curr] {
				if !visited[neighbor] {
					stack = append(stack, neighbor)
					visited[neighbor] = true
					component.Add(&targets[neighbor])
				}
			}
		}

		groups = append(
			groups,
			collections.Map(component.Values(), func(target *Target) Target { return *target }),
		)
	}
	return groups
}

// Given set of targets that define the same headers try to select ones that contain other targets as their direct or transitive dependencies
func SelectRootTargets(targets []Target) []Target {
	allTargets := make(map[label.Label]Target)
	dependentTargets := make(collections.Set[label.Label])

	// Collect all target names
	for _, target := range targets {
		allTargets[target.Name] = target
	}

	// Mark all targets that are listed as dependencies
	for _, target := range targets {
		for dep := range target.Deps {
			if dep.Relative {
				dep = dep.Abs(target.Name.Repo, target.Name.Pkg)
			}
			dependentTargets.Add(dep)
		}
	}

	// Any target not in the dependency map is a root
	roots := make([]Target, 0, len(dependentTargets))
	for name, target := range allTargets {
		if !dependentTargets.Contains(name) {
			roots = append(roots, target)
		}
	}
	return roots
}
