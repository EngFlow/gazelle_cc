// Copyright 2025 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package indexer

import (
	"maps"
	"slices"

	"github.com/EngFlow/gazelle_cc/internal/collections"
	"github.com/bazelbuild/bazel-gazelle/label"
)

// WithAmbigiousTargetsResolved returns a copy of the module with ambiguous target headers resolved.
// Multiple targets may define the same headers when using auto-generated build rules
// (e.g., from Conan integration). This method identifies groups of targets with overlapping
// headers and resolves conflicts by:
//  1. Selecting root targets (those not depended on by other targets in the group)
//  2. Preferring targets with source files over header-only targets
//  3. Merging headers into a common dependent target when one exists
//  4. Excluding headers that appear in multiple targets as a last resort
func (m Module) WithAmbigiousTargetsResolved() Module {
	selectedTargets := map[label.Label]Target{}
	// We need to index only top-level target that depend on all other remaining targets
	for _, intersectingTargets := range GroupTargetsByHeaders(m.Targets) {
		roots := SelectRootTargets(intersectingTargets)
		if len(roots) == 1 { // happy-path, no ambigious headers in targets
			target := roots[0]
			if _, exists := selectedTargets[target.Name]; !exists {
				selectedTargets[target.Name] = target
			}
			continue
		}

		// Try search for common dependant project and merge with it
		if len(roots) != 1 {
			rootNames := collections.MapSlice(roots, func(target Target) label.Label { return target.Name })
			dependantTargets := collections.FilterSlice(m.Targets, func(target Target) bool {
				return slices.ContainsFunc(rootNames, func(dep label.Label) bool {
					dep = dep.Rel(target.Name.Repo, target.Name.Pkg)
					return target.Deps.Contains(dep)
				})
			})
			selected := SelectRootTargets(dependantTargets)
			if len(selected) == 1 {
				selected := selected[0]
				if target, exists := selectedTargets[selected.Name]; exists {
					selected = target
				}
				for _, target := range intersectingTargets {
					if target.Name != selected.Name {
						selected.Hdrs.Join(target.Hdrs)
						selected.Includes.Join(target.Includes)
					}
				}
				selectedTargets[selected.Name] = selected
				continue
			}
		}

		// Resolve by excluding ambigious headers
		// The hdrs sets might be partially disjoint
		counts := map[label.Label]int{}
		for _, root := range roots {
			for _, header := range root.Hdrs.Values() {
				counts[header]++
			}
		}
		ambigiousHdrs := collections.SetOf[label.Label]()
		for header, count := range counts {
			if count >= 2 {
				ambigiousHdrs.Add(header)
			}
		}

		for _, root := range roots {
			root.Hdrs = root.Hdrs.Diff(ambigiousHdrs)
			if len(root.Hdrs) > 0 {
				selectedTargets[root.Name] = root
			}
		}
	}

	// Create copy of the module with selected targets, *(&m) would be simplified to just m
	mRef := &m
	cpy := *mRef
	cpy.Targets = slices.Collect(maps.Values(selectedTargets))
	return cpy
}

// Groups targets into disjoint groups based on the their defined headers.
// Allows to find targets that contain at least 1 common header defined in their definition.
// Used to indentify potentially ambigious headers for external dependency providers that don't
// have well defined control over sources, e.g. auto-generated rules generated by conan integraiton.
// Groups that contain multiple entries can be applied to `SelectRootTargets` helper method to find a target behaving as clousere over overlapping headers.
func GroupTargetsByHeaders(targets []Target) [][]Target {
	var groups [][]Target

	// Build adjacency list: map each target index to its neighbors
	adj := make(map[int][]int)
	n := len(targets)
	for i := range n {
		for j := i + 1; j < n; j++ {
			if (targets[i]).Hdrs.Intersects(targets[j].Hdrs) {
				adj[i] = append(adj[i], j)
				adj[j] = append(adj[j], i)
			}
		}
	}

	// DFS to find connected components
	visited := make([]bool, n)
	for i := range n {
		if visited[i] {
			continue
		}
		stack := []int{i}
		component := collections.SetOf(&targets[i])
		visited[i] = true

		for len(stack) > 0 {
			curr := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			for _, neighbor := range adj[curr] {
				if !visited[neighbor] {
					stack = append(stack, neighbor)
					visited[neighbor] = true
					component.Add(&targets[neighbor])
				}
			}
		}

		groups = append(
			groups,
			collections.MapSlice(component.Values(), func(target *Target) Target { return *target }),
		)
	}
	return groups
}

// Given set of targets that define the same headers try to select ones that contain other targets as their direct or transitive dependencies
func SelectRootTargets(targets []Target) []Target {
	allTargets := make(map[label.Label]Target)
	dependentTargets := make(collections.Set[label.Label])

	// Collect all target names
	for _, target := range targets {
		allTargets[target.Name] = target
	}

	// Mark all targets that are listed as dependencies
	for _, target := range targets {
		for dep := range target.Deps {
			if dep.Relative {
				dep = dep.Abs(target.Name.Repo, target.Name.Pkg)
			}
			dependentTargets.Add(dep)
		}
	}

	// Any target not in the dependency map is a root
	roots := make([]Target, 0, len(dependentTargets))
	for name, target := range allTargets {
		if !dependentTargets.Contains(name) {
			roots = append(roots, target)
		}
	}
	return roots
}
