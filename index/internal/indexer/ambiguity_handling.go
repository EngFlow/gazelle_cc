// Copyright 2025 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package indexer

import (
	"maps"
	"slices"

	"github.com/EngFlow/gazelle_cc/internal/collections"
	"github.com/bazelbuild/bazel-gazelle/label"
)

// WithAmbiguousTargetsResolved returns a copy of the module with ambiguous target headers resolved.
//
// Multiple targets may define the same headers when using auto-generated build rules
// (e.g., from Conan integration). This method identifies groups of targets with overlapping
// headers and resolves conflicts using the following strategies (in order):
//
// Strategy 1 - Single Root: If all targets with overlapping headers form a dependency chain
// where one target depends on all others (directly or transitively), that root target is
// selected and gets all the headers.
//
// Strategy 2 - Common Dependent: If multiple root targets exist (e.g., A and B both define
// header.h, neither depends on the other), but there exists a target C that depends on both
// A and B, then C is selected and all headers from A and B are merged into C.
//
// Strategy 3 - Exclusion: If no common dependent exists, headers that appear in multiple
// root targets are EXCLUDED from all of them. Each target keeps only its unique headers.
// This means some headers may not be indexed at all if they cannot be unambiguously assigned.
//
// Example of Strategy 3:
//
//	Library A defines: [common.h, a_specific.h]
//	Library B defines: [common.h, b_specific.h]
//	No library C depends on both A and B.
//	Result: common.h is excluded from both. A keeps a_specific.h, B keeps b_specific.h.
//
// This conservative approach ensures that the index only contains unambiguous mappings,
// avoiding incorrect dependency resolution at the cost of potentially missing some headers.
func (m Module) WithAmbiguousTargetsResolved() Module {
	selectedTargets := map[label.Label]Target{}

	for _, intersectingTargets := range GroupTargetsByHeaders(m.Targets) {
		roots := SelectRootTargets(intersectingTargets)

		// Strategy 1: Single root - one target depends on all others
		if len(roots) == 1 {
			target := roots[0]
			if _, exists := selectedTargets[target.Name]; !exists {
				selectedTargets[target.Name] = target
			}
			continue
		}

		// Strategy 2: Find a common dependent that depends on multiple roots
		if len(roots) != 1 {
			rootNames := collections.MapSlice(roots, func(target Target) label.Label { return target.Name })
			dependantTargets := collections.FilterSlice(m.Targets, func(target Target) bool {
				return slices.ContainsFunc(rootNames, func(dep label.Label) bool {
					dep = dep.Rel(target.Name.Repo, target.Name.Pkg)
					return target.Deps.Contains(dep)
				})
			})
			selected := SelectRootTargets(dependantTargets)
			if len(selected) == 1 {
				selected := selected[0]
				if target, exists := selectedTargets[selected.Name]; exists {
					selected = target
				}
				for _, target := range intersectingTargets {
					if target.Name != selected.Name {
						selected.Hdrs.Join(target.Hdrs)
						selected.Includes.Join(target.Includes)
					}
				}
				selectedTargets[selected.Name] = selected
				continue
			}
		}

		// Strategy 3: Exclude headers that appear in multiple root targets.
		// Each target keeps only headers unique to it; shared headers are dropped.
		counts := map[label.Label]int{}
		for _, root := range roots {
			for _, header := range root.Hdrs.Values() {
				counts[header]++
			}
		}
		ambiguousHdrs := collections.SetOf[label.Label]()
		for header, count := range counts {
			if count >= 2 {
				ambiguousHdrs.Add(header)
			}
		}

		for _, root := range roots {
			root.Hdrs = root.Hdrs.Diff(ambiguousHdrs)
			if len(root.Hdrs) > 0 {
				selectedTargets[root.Name] = root
			}
		}
	}

	// Create copy of the module with selected targets, *(&m) would be simplified to just m
	mRef := &m
	cpy := *mRef
	cpy.Targets = slices.Collect(maps.Values(selectedTargets))
	return cpy
}

// Groups targets into disjoint groups based on the their defined headers.
// Allows to find targets that contain at least 1 common header defined in their definition.
// Used to identify potentially ambiguous headers for external dependency providers that don't
// have well defined control over sources, e.g. auto-generated rules generated by conan integration.
// Groups that contain multiple entries can be applied to `SelectRootTargets` helper method to find a target behaving as closure over overlapping headers.
func GroupTargetsByHeaders(targets []Target) [][]Target {
	var groups [][]Target

	// Build adjacency list: map each target index to its neighbors
	adj := make(map[int][]int)
	n := len(targets)
	for i := range n {
		for j := i + 1; j < n; j++ {
			if (targets[i]).Hdrs.Intersects(targets[j].Hdrs) {
				adj[i] = append(adj[i], j)
				adj[j] = append(adj[j], i)
			}
		}
	}

	// DFS to find connected components
	visited := make([]bool, n)
	for i := range n {
		if visited[i] {
			continue
		}
		stack := []int{i}
		component := collections.SetOf(&targets[i])
		visited[i] = true

		for len(stack) > 0 {
			curr := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			for _, neighbor := range adj[curr] {
				if !visited[neighbor] {
					stack = append(stack, neighbor)
					visited[neighbor] = true
					component.Add(&targets[neighbor])
				}
			}
		}

		groups = append(
			groups,
			collections.MapSlice(component.Values(), func(target *Target) Target { return *target }),
		)
	}
	return groups
}

// Given set of targets that define the same headers try to select ones that contain other targets as their direct or transitive dependencies
func SelectRootTargets(targets []Target) []Target {
	allTargets := make(map[label.Label]Target)
	dependentTargets := make(collections.Set[label.Label])

	// Collect all target names
	for _, target := range targets {
		allTargets[target.Name] = target
	}

	// Mark all targets that are listed as dependencies
	for _, target := range targets {
		for dep := range target.Deps {
			if dep.Relative {
				dep = dep.Abs(target.Name.Repo, target.Name.Pkg)
			}
			dependentTargets.Add(dep)
		}
	}

	// Any target not in the dependency map is a root
	roots := make([]Target, 0, len(dependentTargets))
	for name, target := range allTargets {
		if !dependentTargets.Contains(name) {
			roots = append(roots, target)
		}
	}
	return roots
}
