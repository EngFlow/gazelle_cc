// Copyright 2025 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cc

import (
	"log"
	"path"
	"slices"
	"strings"

	"github.com/EngFlow/gazelle_cc/internal/collections"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/language/proto"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const ccProtoLibraryHeadersKey = "_proto_headers"

type (
	ccProtoOutputFileNames struct{ pbHeader, pbSource string }
	ccProtoGeneratedFiles  struct{ pbHeaders, pbSources []string }
)

func getGeneratedFileNames(protoFileName string) ccProtoOutputFileNames {
	baseName := strings.TrimSuffix(protoFileName, ".proto")
	return ccProtoOutputFileNames{
		pbHeader: baseName + ".pb.h",
		pbSource: baseName + ".pb.cc",
	}
}

func initCcProtoGeneratedFiles(capactity int) ccProtoGeneratedFiles {
	return ccProtoGeneratedFiles{
		pbHeaders: make([]string, 0, capactity),
		pbSources: make([]string, 0, capactity),
	}
}

func (files ccProtoGeneratedFiles) all() []string {
	return slices.Concat(files.pbHeaders, files.pbSources)
}

func getGeneratedFiles(protoPackage proto.Package) ccProtoGeneratedFiles {
	result := initCcProtoGeneratedFiles(len(protoPackage.Files))
	for _, file := range protoPackage.Files {
		filenames := getGeneratedFileNames(file.Name)
		result.pbHeaders = append(result.pbHeaders, filenames.pbHeader)
		result.pbSources = append(result.pbSources, filenames.pbSource)
	}
	return result
}

func emptyCcProtoLibraryRule(protoLibraryName string) *rule.Rule {
	name := strings.TrimSuffix(protoLibraryName, "_proto") + "_cc_proto"
	return rule.NewRule("cc_proto_library", name)
}

func makeLabel(rule *rule.Rule) label.Label {
	ruleLabel, err := label.Parse(":" + rule.Name())
	if err != nil {
		log.Panicf("failed to generate label of %s(name = %q): %v", rule.Kind(), rule.Name(), err)
	}
	return ruleLabel
}

func generateCcProtoLibraryRule(protoLibraryRule *rule.Rule, pbHeaders []string, buildFile *rule.File) *rule.Rule {
	rule := emptyCcProtoLibraryRule(protoLibraryRule.Name())
	rule.SetAttr("deps", []label.Label{makeLabel(protoLibraryRule)})
	rule.SetPrivateAttr(ccProtoLibraryHeadersKey, pbHeaders)
	setVisibilityIfNeeded(rule, buildFile)
	return rule
}

// Generate cc_proto_library rules based on proto_library rules generated by
// "proto" language extension.
//
// Returns "*.pb.h", "*.pb.cc" sources generated by cc_proto_library, so they
// won't be added to normal cc_library rules. This affects only the special case
// when the developer has manually commited generated files into the source
// tree.
//
// See language/cc/testdata/protobuf_filter_generated test for an example.
func generateProtoLibraryRules(args language.GenerateArgs, result *language.GenerateResult) collections.Set[string] {
	if !getProtoMode(args.Config).ShouldGenerateRules() {
		// Don't create or delete proto rules in this mode. All "*.pb.h",
		// "*.pb.cc", would be added to cc_library
		return make(collections.Set[string])
	}

	var consumedProtoFiles []string

	for _, protoLibraryRule := range args.OtherGen {
		if protoLibraryRule.Kind() == "proto_library" && slices.Contains(protoLibraryRule.PrivateAttrKeys(), proto.PackageKey) {
			protoPackage := protoLibraryRule.PrivateAttr(proto.PackageKey).(proto.Package)
			generatedFiles := getGeneratedFiles(protoPackage)
			consumedProtoFiles = append(consumedProtoFiles, generatedFiles.all()...)

			ccProtoLibraryRule := generateCcProtoLibraryRule(protoLibraryRule, generatedFiles.pbHeaders, args.File)
			result.Gen = append(result.Gen, ccProtoLibraryRule)
			result.Imports = append(result.Imports, nil)
		}
	}

	for _, protoRule := range args.OtherEmpty {
		if protoRule.Kind() == "proto_library" {
			result.Empty = append(result.Empty, emptyCcProtoLibraryRule(protoRule.Name()))
		}
	}

	return collections.ToSet(consumedProtoFiles)
}

func generateProtoImportSpecs(protoLibraryRule *rule.Rule, pkg string) []resolve.ImportSpec {
	if !slices.Contains(protoLibraryRule.PrivateAttrKeys(), ccProtoLibraryHeadersKey) {
		return nil
	}

	makeImportSpec := func(header string) resolve.ImportSpec {
		return resolve.ImportSpec{Lang: languageName, Imp: path.Join(pkg, header)}
	}

	headers := protoLibraryRule.PrivateAttr(ccProtoLibraryHeadersKey).([]string)
	return collections.MapSlice(headers, makeImportSpec)
}
