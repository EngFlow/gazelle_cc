// Copyright 2025 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cc

import (
	"log"
	"path"
	"slices"
	"strings"

	"github.com/EngFlow/gazelle_cc/internal/collections"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/language/proto"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const ccProtoLibraryHeadersKey = "_proto_headers"

type (
	ccProtoOutputFileNames struct{ pbHeader, pbSource string }
	ccProtoHeaders         []string
)

func makeOutputFileNamesFromProto(protoFileName string) ccProtoOutputFileNames {
	baseName := strings.TrimSuffix(protoFileName, ".proto")
	return ccProtoOutputFileNames{
		pbHeader: baseName + ".pb.h",
		pbSource: baseName + ".pb.cc",
	}
}

func extractProtoHeaders(protoPackage proto.Package, consumedProtoFiles collections.Set[string]) ccProtoHeaders {
	headers := make(ccProtoHeaders, 0, len(protoPackage.Files))
	for _, file := range protoPackage.Files {
		filenames := makeOutputFileNamesFromProto(file.Name)
		consumedProtoFiles.Add(filenames.pbHeader).Add(filenames.pbSource)
		headers = append(headers, filenames.pbHeader)
	}
	return headers
}

func emptyCcProtoLibraryRule(protoLibraryName string) *rule.Rule {
	name := strings.TrimSuffix(protoLibraryName, "_proto") + "_cc_proto"
	return rule.NewRule("cc_proto_library", name)
}

func makeLabel(rule *rule.Rule) label.Label {
	ruleLabel, err := label.Parse(":" + rule.Name())
	if err != nil {
		log.Panicf("failed to generate label of %s(name = %q): %v", rule.Kind(), rule.Name(), err)
	}
	return ruleLabel
}

func generateCcProtoLibraryRule(protoLibraryRule *rule.Rule, protoHeaders ccProtoHeaders, buildFile *rule.File, result *language.GenerateResult) *rule.Rule {
	rule := emptyCcProtoLibraryRule(protoLibraryRule.Name())
	rule.SetAttr("deps", []label.Label{makeLabel(protoLibraryRule)})
	rule.SetPrivateAttr(ccProtoLibraryHeadersKey, protoHeaders)
	setVisibilityIfNeeded(rule, buildFile)

	result.Gen = append(result.Gen, rule)
	result.Imports = append(result.Imports, nil)

	return rule
}

// Generate cc_proto_library rules based on proto_library rules generated by
// "proto" language extension.
//
// Returns "*.pb.h" and "*.pb.cc" sources generated by cc_proto_library, so they
// won't be added to normal cc_library rules. This affects only the special case
// when the developer has manually commited generated files into the source
// tree. See language/cc/testdata/protobuf_filter_generated test for an example.
func generateProtoLibraryRules(args language.GenerateArgs, result *language.GenerateResult) collections.Set[string] {
	consumedProtoFiles := make(collections.Set[string])

	if !getProtoMode(args.Config).ShouldGenerateRules() {
		// Don't create or delete proto rules in this mode. All "*.pb.h",
		// "*.pb.cc", would be added to cc_library
		return consumedProtoFiles
	}

	for _, protoRule := range args.OtherGen {
		if protoRule.Kind() == "proto_library" && slices.Contains(protoRule.PrivateAttrKeys(), proto.PackageKey) {
			protoPackage := protoRule.PrivateAttr(proto.PackageKey).(proto.Package)
			protoHeaders := extractProtoHeaders(protoPackage, consumedProtoFiles)
			generateCcProtoLibraryRule(protoRule, protoHeaders, args.File, result)
		}
	}

	for _, protoRule := range args.OtherEmpty {
		if protoRule.Kind() == "proto_library" {
			result.Empty = append(result.Empty, emptyCcProtoLibraryRule(protoRule.Name()))
		}
	}

	return consumedProtoFiles
}

func generateProtoImportSpecs(protoLibraryRule *rule.Rule, pkg string) []resolve.ImportSpec {
	if !slices.Contains(protoLibraryRule.PrivateAttrKeys(), ccProtoLibraryHeadersKey) {
		return nil
	}

	makeImportSpec := func(header string) resolve.ImportSpec {
		return resolve.ImportSpec{Lang: languageName, Imp: path.Join(pkg, header)}
	}

	headers := protoLibraryRule.PrivateAttr(ccProtoLibraryHeadersKey).(ccProtoHeaders)
	return collections.MapSlice(headers, makeImportSpec)
}
