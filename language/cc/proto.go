// Copyright 2026 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cc

import (
	"log"
	"maps"
	"path"
	"slices"
	"strings"

	"github.com/EngFlow/gazelle_cc/internal/collections"
	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/language/proto"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// Key of the private attribute used to store the []string list of proto header
// files generated by cc_proto_library rules. It's populated during rule
// generation and used to propagate appropriate resolve.ImportSpec later.
const ccProtoLibraryHeadersKey = "_proto_headers"

func getGeneratedFiles(protoPackage proto.Package) (pbHeaders, pbSources, grpcHeaders, grpcSources []string) {
	pbHeaders = make([]string, 0, len(protoPackage.Files))
	pbSources = make([]string, 0, len(protoPackage.Files))

	for _, file := range protoPackage.Files {
		baseName := strings.TrimSuffix(file.Name, ".proto")
		pbHeaders = append(pbHeaders, baseName+".pb.h")
		pbSources = append(pbSources, baseName+".pb.cc")
		if file.HasServices {
			grpcHeaders = append(grpcHeaders, baseName+".grpc.pb.h")
			grpcSources = append(grpcSources, baseName+".grpc.pb.cc")
		}
	}

	return
}

func newEmptyCcProtoLibraryRule(protoLibraryName string) *rule.Rule {
	name := strings.TrimSuffix(protoLibraryName, "_proto") + "_cc_proto"
	return rule.NewRule("cc_proto_library", name)
}

func newEmptyCcGrpcLibraryRule(protoLibraryName string) *rule.Rule {
	name := strings.TrimSuffix(protoLibraryName, "_proto") + "_cc_grpc"
	return rule.NewRule("cc_grpc_library", name)
}

func makeRelativeLabel(rule *rule.Rule) label.Label {
	return label.Label{Name: rule.Name(), Relative: true}
}

func generateCcProtoLibraryRule(protoLibraryRule *rule.Rule, pbHeaders []string, buildFile *rule.File) *rule.Rule {
	rule := newEmptyCcProtoLibraryRule(protoLibraryRule.Name())
	rule.SetAttr("deps", []label.Label{makeRelativeLabel(protoLibraryRule)})
	rule.SetPrivateAttr(ccProtoLibraryHeadersKey, pbHeaders)
	setVisibilityIfNeeded(rule, buildFile)
	return rule
}

func generateCcGrpcLibraryRule(protoLibraryRule, ccProtoLibraryRule *rule.Rule, grpcHeaders []string, buildFile *rule.File) *rule.Rule {
	rule := newEmptyCcGrpcLibraryRule(protoLibraryRule.Name())
	rule.SetAttr("srcs", []label.Label{makeRelativeLabel(protoLibraryRule)})
	rule.SetAttr("deps", newCcPlatformStringsExprs(collections.SetOf(makeRelativeLabel(ccProtoLibraryRule)), nil, true))
	rule.SetAttr("grpc_only", true)
	rule.SetPrivateAttr(ccProtoLibraryHeadersKey, grpcHeaders)
	setVisibilityIfNeeded(rule, buildFile)
	return rule
}

func generateComposedCcGrpcLibraryRule(protoPackage proto.Package, protoOnly bool, headers []string, buildFile *rule.File) *rule.Rule {
	rule := rule.NewRule("cc_grpc_library", protoPackage.Name+"_cc_proto")
	rule.SetAttr("srcs", slices.Collect(maps.Keys(protoPackage.Files)))
	rule.SetAttr("deps", newCcPlatformStringsExprs(nil, nil, true))
	rule.SetAttr("grpc_only", false)
	rule.SetAttr("proto_only", protoOnly)
	rule.SetAttr("well_known_protos", false)
	rule.SetPrivateAttr(ccProtoLibraryHeadersKey, headers)
	setVisibilityIfNeeded(rule, buildFile)
	return rule
}

// Generate cc_proto_library and cc_grpc_library rules based on proto_library
// rules generated by "proto" language extension.
//
// Returns "*.pb.h", "*.pb.cc" sources generated by cc_proto_library and
// "*.grpc.pb.h", "*.grpc.pb.cc" sources generated by cc_grpc_library, so they
// won't be added to normal cc_library rules. This affects only the special case
// when the developer has manually commited generated files into the source
// tree.
//
// See language/cc/testdata/protobuf_filter_generated test for an example.
func generateDefaultProtoLibraryRules(args language.GenerateArgs, result *language.GenerateResult) collections.Set[string] {
	consumedProtoFiles := make(collections.Set[string])

	for _, protoLibraryRule := range args.OtherGen {
		protoPackage, ok := protoLibraryRule.PrivateAttr(proto.PackageKey).(proto.Package)
		if !ok || protoLibraryRule.Kind() != "proto_library" {
			continue
		}

		pbHeaders, pbSources, grpcHeaders, grpcSources := getGeneratedFiles(protoPackage)
		consumedProtoFiles.AddSlice(pbHeaders).AddSlice(pbSources).AddSlice(grpcHeaders).AddSlice(grpcSources)

		ccProtoLibraryRule := generateCcProtoLibraryRule(protoLibraryRule, pbHeaders, args.File)
		result.Gen = append(result.Gen, ccProtoLibraryRule)
		result.Imports = append(result.Imports, ccImports{})

		if protoPackage.HasServices {
			ccGrpcLibraryRule := generateCcGrpcLibraryRule(protoLibraryRule, ccProtoLibraryRule, grpcHeaders, args.File)
			result.Gen = append(result.Gen, ccGrpcLibraryRule)
			result.Imports = append(result.Imports, ccImports{})
		}
	}

	for _, protoRule := range args.OtherEmpty {
		if protoRule.Kind() == "proto_library" {
			result.Empty = append(result.Empty, newEmptyCcProtoLibraryRule(protoRule.Name()), newEmptyCcGrpcLibraryRule(protoRule.Name()))
		}
	}

	return consumedProtoFiles
}

func collectProtoPackages(args language.GenerateArgs) []proto.Package {
	protoPackages := make(map[string]*proto.Package, len(args.RegularFiles))

	for _, protoFile := range args.RegularFiles {
		if !strings.HasSuffix(protoFile, ".proto") {
			continue
		}

		protoFileInfo := proto.ProtoFileInfo(args.Dir, protoFile)
		protoPackage, exists := protoPackages[protoFileInfo.PackageName]
		if !exists {
			protoPackages[protoFileInfo.PackageName] = &proto.Package{
				Name:    protoFileInfo.PackageName,
				Files:   map[string]proto.FileInfo{},
				Imports: map[string]bool{},
				Options: map[string]string{},
			}
			protoPackage = protoPackages[protoFileInfo.PackageName]
		}

		protoPackage.Files[protoFileInfo.Name] = protoFileInfo
		for _, imp := range protoFileInfo.Imports {
			protoPackage.Imports[imp] = true
		}
		for _, opt := range protoFileInfo.Options {
			protoPackage.Options[opt.Key] = opt.Value
		}
		protoPackage.HasServices = protoPackage.HasServices || protoFileInfo.HasServices
	}

	result := make([]proto.Package, 0, len(protoPackages))
	for _, pkg := range protoPackages {
		result = append(result, *pkg)
	}
	return result
}

// Generate cc_grpc_library rules in the mode grpc_only=False. In this mode we
// cannot depend on proto_library rules created by "proto" language extension;
// in practive it has to be disabled to avoid conflicts. Instead, we collect all
// proto files manually.
//
// Returns "*.pb.h", "*.pb.cc", "*.grpc.pb.cc" sources generated by
// cc_grpc_library, so they won't be added to normal cc_library rules. This
// affects only the special case when the developer has manually commited
// generated files into the source tree.
func generateComposedGrpcRules(args language.GenerateArgs, result *language.GenerateResult) collections.Set[string] {
	consumedProtoFiles := make(collections.Set[string])

	protoPackages := collectProtoPackages(args)
	if len(protoPackages) > 1 {
		// Mirror the "default" mode bahavior of "gazelle:proto" directive
		log.Printf("gazelle_cc: %s: directory contains multiple proto packages. Gazelle can only generate a cc_grpc_library for one package.", args.Dir)
	} else if len(protoPackages) == 1 {
		protoPackage := protoPackages[0]
		pbHeaders, _, grpcHeaders, _ := getGeneratedFiles(protoPackage)
		allHeaders := slices.Concat(pbHeaders, grpcHeaders)
		consumedProtoFiles.AddSlice(allHeaders)

		protoOnly := !protoPackage.HasServices
		ccGrpcLibraryRule := generateComposedCcGrpcLibraryRule(protoPackage, protoOnly, allHeaders, args.File)

		result.Gen = append(result.Gen, ccGrpcLibraryRule)
		result.Imports = append(result.Imports, ccImports{})
	}

	return consumedProtoFiles
}

func shouldGenerateDefaultProtoLibraryRules(config *config.Config) bool {
	ccConfig := getCcConfig(config)
	protoExtensionConfig := proto.GetProtoConfig(config)
	return protoExtensionConfig != nil && protoExtensionConfig.Mode.ShouldGenerateRules() && ccConfig.generateProto == generateProtoMode_default
}

func shouldGenerateComposedGrpcRules(config *config.Config) bool {
	return getCcConfig(config).generateProto == generateProtoMode_composedGrpc
}

func generateProtoLibraryRules(args language.GenerateArgs, result *language.GenerateResult) collections.Set[string] {
	switch {
	case shouldGenerateDefaultProtoLibraryRules(args.Config):
		return generateDefaultProtoLibraryRules(args, result)
	case shouldGenerateComposedGrpcRules(args.Config):
		return generateComposedGrpcRules(args, result)
	default:
		// Don't create or delete proto rules in this mode. All "*.pb.h",
		// "*.pb.cc", would be added to cc_library
		return make(collections.Set[string])
	}
}

func generateProtoImportSpecs(protoLibraryRule *rule.Rule, pkg string) []resolve.ImportSpec {
	headers, ok := protoLibraryRule.PrivateAttr(ccProtoLibraryHeadersKey).([]string)
	if !ok {
		return nil
	}
	return collections.MapSlice(headers, func(header string) resolve.ImportSpec {
		return resolve.ImportSpec{Lang: languageName, Imp: path.Join(pkg, header)}
	})
}
