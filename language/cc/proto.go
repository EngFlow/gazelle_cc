// Copyright 2026 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cc

import (
	"path"
	"strings"

	"github.com/EngFlow/gazelle_cc/internal/collections"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/language/proto"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// Key of the private attribute used to store the []string list of proto header
// files generated by cc_proto_library rules. It's populated during rule
// generation and used to propagate appropriate resolve.ImportSpec later.
const ccProtoLibraryHeadersKey = "_proto_headers"

func getGeneratedFiles(protoPackage proto.Package) (pbHeaders, pbSources, grpcHeaders, grpcSources []string) {
	pbHeaders = make([]string, 0, len(protoPackage.Files))
	pbSources = make([]string, 0, len(protoPackage.Files))

	for _, file := range protoPackage.Files {
		baseName := strings.TrimSuffix(file.Name, ".proto")
		pbHeaders = append(pbHeaders, baseName+".pb.h")
		pbSources = append(pbSources, baseName+".pb.cc")
		if file.HasServices {
			grpcHeaders = append(grpcHeaders, baseName+".grpc.pb.h")
			grpcSources = append(grpcSources, baseName+".grpc.pb.cc")
		}
	}

	return
}

func newEmptyCcProtoLibraryRule(protoLibraryName string) *rule.Rule {
	name := strings.TrimSuffix(protoLibraryName, "_proto") + "_cc_proto"
	return rule.NewRule("cc_proto_library", name)
}

func newEmptyCcGrpcLibraryRule(protoLibraryName string) *rule.Rule {
	name := strings.TrimSuffix(protoLibraryName, "_proto") + "_cc_grpc"
	return rule.NewRule("cc_grpc_library", name)
}

func makeRelativeLabel(rule *rule.Rule) label.Label {
	return label.Label{Name: rule.Name(), Relative: true}
}

func generateCcProtoLibraryRule(protoLibraryRule *rule.Rule, pbHeaders []string, buildFile *rule.File) *rule.Rule {
	rule := newEmptyCcProtoLibraryRule(protoLibraryRule.Name())
	rule.SetAttr("deps", []label.Label{makeRelativeLabel(protoLibraryRule)})
	rule.SetPrivateAttr(ccProtoLibraryHeadersKey, pbHeaders)
	setVisibilityIfNeeded(rule, buildFile)
	return rule
}

func generateCcGrpcLibraryRule(protoLibraryRule, ccProtoLibraryRule *rule.Rule, grpcHeaders []string, buildFile *rule.File) *rule.Rule {
	rule := newEmptyCcGrpcLibraryRule(protoLibraryRule.Name())
	rule.SetAttr("srcs", []label.Label{makeRelativeLabel(protoLibraryRule)})
	rule.SetAttr("deps", []label.Label{makeRelativeLabel(ccProtoLibraryRule)})
	rule.SetAttr("grpc_only", true)
	rule.SetPrivateAttr(ccProtoLibraryHeadersKey, grpcHeaders)
	setVisibilityIfNeeded(rule, buildFile)
	return rule
}

// Generate cc_proto_library and cc_grpc_library rules based on proto_library
// rules generated by "proto" language extension.
//
// Returns "*.pb.h", "*.pb.cc" sources generated by cc_proto_library and
// "*.grpc.pb.h", "*.grpc.pb.cc" sources generated by cc_grpc_library, so they
// won't be added to normal cc_library rules. This affects only the special case
// when the developer has manually commited generated files into the source
// tree.
//
// See language/cc/testdata/protobuf_filter_generated test for an example.
func generateProtoLibraryRules(args language.GenerateArgs, result *language.GenerateResult) collections.Set[string] {
	consumedProtoFiles := make(collections.Set[string])
	if !getProtoMode(args.Config).ShouldGenerateRules() {
		// Don't create or delete proto rules in this mode. All "*.pb.h",
		// "*.pb.cc", would be added to cc_library
		return consumedProtoFiles
	}

	for _, protoLibraryRule := range args.OtherGen {
		protoPackage, ok := protoLibraryRule.PrivateAttr(proto.PackageKey).(proto.Package)
		if !ok || protoLibraryRule.Kind() != "proto_library" {
			continue
		}

		pbHeaders, pbSources, grpcHeaders, grpcSources := getGeneratedFiles(protoPackage)
		consumedProtoFiles.AddSlice(pbHeaders).AddSlice(pbSources).AddSlice(grpcHeaders).AddSlice(grpcSources)

		ccProtoLibraryRule := generateCcProtoLibraryRule(protoLibraryRule, pbHeaders, args.File)
		result.Gen = append(result.Gen, ccProtoLibraryRule)
		result.Imports = append(result.Imports, ccImports{})

		if protoPackage.HasServices {
			ccGrpcLibraryRule := generateCcGrpcLibraryRule(protoLibraryRule, ccProtoLibraryRule, grpcHeaders, args.File)
			result.Gen = append(result.Gen, ccGrpcLibraryRule)
			result.Imports = append(result.Imports, ccImports{})
		}
	}

	for _, protoRule := range args.OtherEmpty {
		if protoRule.Kind() == "proto_library" {
			result.Empty = append(result.Empty, newEmptyCcProtoLibraryRule(protoRule.Name()), newEmptyCcGrpcLibraryRule(protoRule.Name()))
		}
	}

	return consumedProtoFiles
}

func generateProtoImportSpecs(protoLibraryRule *rule.Rule, pkg string) []resolve.ImportSpec {
	headers, ok := protoLibraryRule.PrivateAttr(ccProtoLibraryHeadersKey).([]string)
	if !ok {
		return nil
	}
	return collections.MapSlice(headers, func(header string) resolve.ImportSpec {
		return resolve.ImportSpec{Lang: languageName, Imp: path.Join(pkg, header)}
	})
}
